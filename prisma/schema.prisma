generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String        @id @default(cuid())
  name                String
  lastName            String
  email               String        @unique
  password            String
  phone               String
  birthDate           DateTime
  country             String
  state               String
  city                String
  currency            String
  preferredLanguage   String
  occupation          String
  company             String?
  verified            Boolean       @default(false)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  onboarding          Boolean       @default(false)
  onboardingCompleted Boolean       @default(false)

  // Trial tracking
  hasUsedTrial        Boolean       @default(false)

  // Password Reset Fields
  resetCode           String?
  resetCodeExpires    DateTime?
  onboardingData      Onboarding?
  budgets             Budget[]
  transactions        Transaction[]
  goals               Goal[]
  
  // Gamificación
  gamificationEvents  GamificationEvent[]
  finScoreHistory     FinScoreHistory[]
  userStreak          UserStreak?
  userBadges          UserBadge[]
  challengeParticipants ChallengeParticipant[]

  // Suscripciones y Pagos
  subscription        Subscription?
  payments            Payment[]
  stripeCustomerId    String?       @unique

  // Email Sync
  emailConnections    EmailConnection[]

  // Notificaciones Push (FCM)
  devices                   UserDevice[]
  notificationPreferences   NotificationPreferences?

  // Recordatorios de Pago
  paymentReminders          PaymentReminder[]

  // Sistema de Referidos
  referralCode              ReferralCode?
  referralsMade             Referral[]        @relation("ReferralsMade")
  referralsReceived         Referral?         @relation("ReferralsReceived")
  referralRewards           ReferralReward[]

  // Tips Financieros
  tipHistory                UserTipHistory[]

  // Reportes Semanales PRO
  weeklyReports             WeeklyReport[]

  @@map("users")
}

model Transaction {
  id          String          @id @default(cuid())
  userId      String
  amount      Float
  type        TransactionType
  description String?
  date        DateTime        @default(now())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  category_id String
  category    Category        @relation(fields: [category_id], references: [id])
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transactions")
}

model Budget {
  id               String   @id @default(uuid())
  amount           Float
  alert_percentage Float    @default(80)
  category_id      String
  created_at       DateTime @default(now())
  end_date         DateTime
  is_active        Boolean  @default(true)
  name             String
  period           String
  spent            Float    @default(0)
  start_date       DateTime
  updated_at       DateTime @updatedAt
  user_id          String
  category         Category @relation(fields: [category_id], references: [id])
  user             User     @relation(fields: [user_id], references: [id])

  @@map("budgets")
}

model Onboarding {
  id                 String   @id @default(cuid())
  userId             String   @unique
  mainGoals          Json
  mainChallenge      String
  mainChallengeOther String?
  savingHabit        String
  emergencyFund      String
  financialFeeling   String
  incomeRange        String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])
}

model Category {
  id           String          @id @default(cuid())
  name         String
  type         TransactionType
  icon         String
  isDefault    Boolean         @default(true)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  budgets      Budget[]
  transactions Transaction[]
  goals        Goal[]
  merchantMappings MerchantCategoryMapping[]

  @@map("categories")
}

model Goal {
  id                        String    @id @default(uuid())
  userId                    String
  name                      String
  description               String?
  targetAmount              Float
  currentAmount             Float     @default(0)
  targetDate                DateTime?
  categoryId                String
  priority                  String    @default("medium")
  isCompleted               Boolean   @default(false)
  isActive                  Boolean   @default(true)
  monthlyTargetPercentage   Float?
  monthlyContributionAmount Float?
  contributionsCount        Int       @default(0)
  lastContributionDate      DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  user                      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  category                  Category  @relation(fields: [categoryId], references: [id])

  @@map("goals")
}

enum TransactionType {
  INCOME
  EXPENSE
}

// =============================================
// MODELOS DE GAMIFICACIÓN
// =============================================

// Sistema de Eventos de Gamificación
model GamificationEvent {
  id            String   @id @default(cuid())
  userId        String
  eventType     String   // 'add_tx', 'goal_complete', 'budget_overspend', etc.
  eventData     Json?    // Datos específicos del evento
  pointsAwarded Int      @default(0)
  createdAt     DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("gamification_events")
  @@index([userId, eventType])
  @@index([createdAt])
}

// FinScore Histórico  
model FinScoreHistory {
  id           String   @id @default(cuid())
  userId       String
  score        Int      // 0-100
  breakdown    Json     // {savings: 25, budget: 20, streak: 15, debt: 10}
  calculatedAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("finscore_history")
  @@index([userId, calculatedAt])
}

// Sistema de Rachas
model UserStreak {
  id                      String    @id @default(cuid())
  userId                  String    @unique
  currentStreak           Int       @default(0)
  longestStreak           Int       @default(0)
  lastActivityDate        DateTime?
  streakType              String    @default("daily") // 'daily', 'budget', 'savings'
  salvividasUsedThisMonth Boolean   @default(false)
  lastSalvividasDate      DateTime?
  updatedAt               DateTime  @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_streaks")
}

// Sistema de Badges
model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  badgeId   String   // 'primer_paso', 'planificador', etc.
  earnedAt  DateTime @default(now())
  isFeatured Boolean @default(false)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId])
  @@map("user_badges")
  @@index([userId])
}

// Desafíos Mensuales
model MonthlyChallenge {
  id            String   @id @default(cuid())
  name          String
  description   String
  startDate     DateTime
  endDate       DateTime
  criteria      Json     // Criterios específicos del desafío
  rewardBadgeId String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  
  participants ChallengeParticipant[]
  
  @@map("monthly_challenges")
  @@index([isActive, startDate, endDate])
}

// Participación en Desafíos
model ChallengeParticipant {
  id          String   @id @default(cuid())
  userId      String
  challengeId String
  joinedAt    DateTime @default(now())
  progress    Json     @default("{}")
  completed   Boolean  @default(false)
  rank        Int?     // Para rankings
  completedAt DateTime?
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge MonthlyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, challengeId])
  @@map("challenge_participants")
  @@index([challengeId, completed])
  @@index([userId])
}

// Enums para Gamificación
enum EventType {
  ADD_TX
  EDIT_TX
  DELETE_TX
  CREATE_BUDGET
  OVERSPEND
  WITHIN_BUDGET
  CREATE_GOAL
  GOAL_CONTRIB
  GOAL_COMPLETE
  TIP_ACCEPTED
  TIP_IGNORED
  DAILY_OPEN
  STREAK_BREAK
}

enum BadgeType {
  PRIMER_PASO
  PLANIFICADOR
  AHORRO_ROOKIE
  ZENIO_LOVER
  ANTI_DOOM_SPENDER
  RACHA_FUEGO
  AHORRADOR_NOVATO
  PRESUPUESTO_MAESTRO
  META_CRUSHER
}

// =============================================
// MODELOS DE SUSCRIPCIONES Y PAGOS
// =============================================

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  plan                 SubscriptionPlan   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  stripePriceId        String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  trialEndsAt          DateTime?
  trialStartedAt       DateTime?
  trialNotificationsSent Json?            @default("[]") // Array of sent notification types: ["TRIAL_WELCOME", "TRIAL_DAY_3", etc.]
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  // Contador de consultas de Zenio AI
  zenioQueriesUsed     Int                @default(0)
  zenioQueriesResetAt  DateTime           @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
  @@index([userId])
  @@index([status])
}

model Payment {
  id                    String        @id @default(cuid())
  userId                String
  subscriptionId        String?
  amount                Float
  currency              String        @default("usd")
  status                PaymentStatus
  stripePaymentIntentId String?       @unique
  stripeInvoiceId       String?       @unique
  description           String?
  createdAt             DateTime      @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
  @@index([userId])
  @@index([status])
}

enum SubscriptionPlan {
  FREE
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
  INCOMPLETE
  INCOMPLETE_EXPIRED
  UNPAID
}

enum PaymentStatus {
  SUCCEEDED
  FAILED
  PENDING
  REFUNDED
  CANCELED
}

// Registro de dispositivos que ya usaron trial (anti-abuso)
model TrialDeviceRegistry {
  id              String   @id @default(cuid())
  deviceId        String   @unique  // Identificador único del dispositivo
  platform        String?           // ios, android
  deviceName      String?           // "iPhone 15", "Samsung Galaxy S24"
  usedByUserId    String            // Usuario que usó el trial
  usedByEmail     String            // Email con el que se registró
  usedAt          DateTime @default(now())

  @@map("trial_device_registry")
  @@index([deviceId])
  @@index([usedByUserId])
}

// =============================================
// MODELOS DE EMAIL SYNC (Importacion de Gastos)
// =============================================

// Conexion de email del usuario
model EmailConnection {
  id                  String              @id @default(cuid())
  userId              String
  provider            EmailProvider       @default(GMAIL)
  email               String
  accessToken         String
  refreshToken        String?
  tokenExpiresAt      DateTime?
  isActive            Boolean             @default(true)
  lastSyncAt          DateTime?
  lastSyncStatus      EmailSyncStatus     @default(PENDING)
  lastSyncError       String?
  syncFrequencyHours  Int                 @default(1)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankFilters         BankEmailFilter[]
  importedEmails      ImportedBankEmail[]
  syncLogs            EmailSyncLog[]

  @@unique([userId, provider])
  @@map("email_connections")
  @@index([userId])
  @@index([isActive, lastSyncAt])
}

// Filtros de bancos configurados
model BankEmailFilter {
  id                String          @id @default(cuid())
  emailConnectionId String
  bankName          String
  senderEmails      String[]
  subjectKeywords   String[]
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  emailConnection   EmailConnection @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@map("bank_email_filters")
  @@index([emailConnectionId])
}

// Emails bancarios importados
model ImportedBankEmail {
  id                String                @id @default(cuid())
  emailConnectionId String
  gmailMessageId    String
  subject           String
  senderEmail       String
  receivedAt        DateTime
  rawContent        String?
  parsedData        Json?
  status            ImportedEmailStatus   @default(PENDING)
  errorMessage      String?
  transactionId     String?
  createdAt         DateTime              @default(now())
  processedAt       DateTime?

  emailConnection   EmailConnection       @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@unique([emailConnectionId, gmailMessageId])
  @@map("imported_bank_emails")
  @@index([emailConnectionId, status])
  @@index([gmailMessageId])
}

// Log de sincronizaciones
model EmailSyncLog {
  id                  String          @id @default(cuid())
  emailConnectionId   String
  startedAt           DateTime        @default(now())
  completedAt         DateTime?
  status              EmailSyncStatus
  emailsFound         Int             @default(0)
  emailsProcessed     Int             @default(0)
  emailsSkipped       Int             @default(0)
  transactionsCreated Int             @default(0)
  errorMessage        String?

  emailConnection     EmailConnection @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@map("email_sync_logs")
  @@index([emailConnectionId, startedAt])
}

// Bancos soportados
model SupportedBank {
  id              String    @id @default(cuid())
  name            String    @unique
  country         String    @default("DO")
  senderEmails    String[]
  subjectPatterns String[]
  parserTemplate  String?
  isActive        Boolean   @default(true)
  logoUrl         String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("supported_banks")
  @@index([country, isActive])
}

enum EmailProvider {
  GMAIL
  OUTLOOK
  IMAP
}

enum EmailSyncStatus {
  PENDING
  IN_PROGRESS
  SUCCESS
  FAILED
  PARTIAL
}

enum ImportedEmailStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  SKIPPED
  DUPLICATE
}

// =============================================
// MODELOS DE NOTIFICACIONES PUSH (FCM)
// =============================================

// Dispositivos del usuario para notificaciones push
model UserDevice {
  id          String   @id @default(cuid())
  userId      String
  fcmToken    String   @unique
  platform    DevicePlatform
  deviceName  String?
  appVersion  String?
  isActive    Boolean  @default(true)
  lastUsedAt  DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_devices")
  @@index([userId, isActive])
  @@index([fcmToken])
}

// Preferencias de notificación del usuario
model NotificationPreferences {
  id                    String   @id @default(cuid())
  userId                String   @unique

  // Tipos de notificaciones habilitadas
  emailSyncEnabled      Boolean  @default(true)
  budgetAlertsEnabled   Boolean  @default(true)
  goalRemindersEnabled  Boolean  @default(true)
  weeklyReportEnabled   Boolean  @default(true)
  tipsEnabled           Boolean  @default(true)
  paymentRemindersEnabled Boolean @default(true)
  antExpenseAlertsEnabled Boolean @default(true)
  trialNotificationsEnabled Boolean @default(true)

  // Umbral de alerta de presupuesto (porcentaje)
  budgetAlertThreshold  Int      @default(80)

  // Umbral de alerta de gastos hormiga (porcentaje del gasto total)
  antExpenseAlertThreshold Int   @default(20)

  // Configuración de detección de gastos hormiga (PRO)
  antExpenseAmountThreshold Int  @default(500)  // Monto máximo para considerar gasto hormiga
  antExpenseMinFrequency    Int  @default(3)    // Frecuencia mínima de repeticiones

  // Frecuencia de recordatorio de metas (días sin contribuir: 0=nunca, 3, 7, 14, 30)
  goalReminderFrequency    Int   @default(7)

  // Horario de notificaciones (para evitar molestias)
  quietHoursStart       Int?     // Hora en formato 24h (ej: 22 = 10pm)
  quietHoursEnd         Int?     // Hora en formato 24h (ej: 8 = 8am)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

// Historial de notificaciones enviadas
model NotificationLog {
  id          String             @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  body        String
  data        Json?
  status      NotificationStatus @default(PENDING)
  sentAt      DateTime?
  readAt      DateTime?
  errorMessage String?
  createdAt   DateTime           @default(now())

  @@map("notification_logs")
  @@index([userId, createdAt])
  @@index([type, status])
}

enum DevicePlatform {
  ANDROID
  IOS
}

enum NotificationType {
  EMAIL_SYNC_COMPLETE
  BUDGET_ALERT
  BUDGET_EXCEEDED
  GOAL_REMINDER
  GOAL_ACHIEVED
  WEEKLY_REPORT
  TIP
  SYSTEM
  PAYMENT_REMINDER
  PAYMENT_DUE_TODAY
  PAYMENT_OVERDUE
  ANT_EXPENSE_ALERT
  TRIAL_WELCOME
  TRIAL_DAY_3
  TRIAL_DAY_5
  TRIAL_ENDING
  TRIAL_ENDED
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  READ
}

// Historial de tips financieros enviados (para evitar repetición)
model UserTipHistory {
  id        String   @id @default(cuid())
  userId    String
  tipHash   String   // Hash del contenido para detectar duplicados
  title     String
  content   String   @db.Text
  category  String?  // spending, savings, goals, budget, seasonal, etc.
  sentAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_tip_history")
  @@index([userId, sentAt])
  @@index([userId, tipHash])
}

// =============================================
// MODELOS DE RECORDATORIOS DE PAGO
// =============================================

model PaymentReminder {
  id              String          @id @default(cuid())
  userId          String

  // Información del pago
  name            String          // "Visa Banco Popular", "Préstamo Auto"
  type            PaymentType     @default(CREDIT_CARD)

  // Fechas importantes
  dueDay          Int             // Día de pago (1-31)
  cutoffDay       Int?            // Día de corte (solo para tarjetas de crédito)

  // Monto (opcional)
  amount          Decimal?        @db.Decimal(12, 2)
  currency        String          @default("DOP")

  // Límites de tarjeta de crédito (solo para CREDIT_CARD)
  creditLimit     Decimal?        @db.Decimal(12, 2)  // Límite en moneda local
  isDualCurrency  Boolean         @default(false)     // Si es tarjeta de doble saldo
  creditLimitUSD  Decimal?        @db.Decimal(12, 2)  // Límite en USD (si es doble saldo)

  // Configuración de notificaciones
  reminderDays    Int[]           @default([3, 1, 0]) // Días antes para notificar
  notifyOnCutoff  Boolean         @default(false)     // Notificar en día de corte

  // Estado
  isActive        Boolean         @default(true)

  // Tracking de notificaciones
  lastNotifiedAt  DateTime?
  lastDueDate     DateTime?       // Última fecha de vencimiento calculada

  // Notas adicionales
  notes           String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payment_reminders")
  @@index([userId, isActive])
  @@index([dueDay])
}

enum PaymentType {
  CREDIT_CARD   // Tarjeta de crédito
  LOAN          // Préstamo
  MORTGAGE      // Hipoteca
  UTILITY       // Servicios (agua, luz, internet)
  INSURANCE     // Seguros
  SUBSCRIPTION  // Suscripciones
  OTHER         // Otros
}

// =============================================
// MODELO DE APRENDIZAJE DE CATEGORIZACIÓN
// =============================================

// Mapeo de comercios a categorías (sistema de aprendizaje)
model MerchantCategoryMapping {
  id              String   @id @default(cuid())

  // Usuario (null = mapeo global)
  userId          String?

  // Nombre del comercio normalizado (uppercase, sin espacios extra)
  merchantName    String

  // Patrón alternativo para variantes (ej: "FARM*" matchea "FARMACIA CAROL", "FARM RD", etc.)
  merchantPattern String?

  // Categoría asignada
  categoryId      String

  // Estadísticas de uso
  timesUsed       Int      @default(1)

  // Para mapeos globales: cuántos usuarios diferentes lo confirmaron
  confirmedByUsers Int     @default(1)

  // Origen del mapeo
  source          MappingSource @default(USER_CORRECTION)

  // Confianza del mapeo (0-100) - para mapeos globales
  confidence      Int      @default(100)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  category        Category @relation(fields: [categoryId], references: [id])

  // Índices para búsqueda eficiente
  @@unique([userId, merchantName])
  @@index([merchantName])
  @@index([userId])
  @@index([categoryId])
  @@map("merchant_category_mappings")
}

enum MappingSource {
  USER_CORRECTION    // Usuario corrigió manualmente
  ZENIO_CORRECTION   // Usuario corrigió via Zenio
  AI_CONFIRMED       // IA categorizó y usuario no corrigió (alta confianza)
  SYSTEM_DEFAULT     // Mapeo por defecto del sistema
}

// =============================================
// MODELOS DE SISTEMA DE REFERIDOS
// =============================================

// Código de referido único por usuario
model ReferralCode {
  id            String   @id @default(cuid())
  userId        String   @unique
  code          String   @unique  // FINZEN-JUAN-X7K9
  isActive      Boolean  @default(true)
  usageCount    Int      @default(0)
  maxUsages     Int?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  referrals     Referral[]

  @@map("referral_codes")
  @@index([code])
}

// Tracking de referido: referrer -> referee
model Referral {
  id              String         @id @default(cuid())
  referralCodeId  String
  referrerId      String
  refereeId       String         @unique  // Solo puede ser referido una vez
  refereeEmail    String
  status          ReferralStatus @default(PENDING)

  createdAt       DateTime       @default(now())
  convertedAt     DateTime?
  rewardedAt      DateTime?
  expiredAt       DateTime?
  stripeInvoiceId String?

  referralCode    ReferralCode   @relation(fields: [referralCodeId], references: [id])
  referrer        User           @relation("ReferralsMade", fields: [referrerId], references: [id])
  referee         User           @relation("ReferralsReceived", fields: [refereeId], references: [id])
  rewards         ReferralReward[]

  @@map("referrals")
  @@index([referrerId])
  @@index([status])
}

// Tracking de recompensas ganadas/usadas
model ReferralReward {
  id            String       @id @default(cuid())
  userId        String
  referralId    String
  type          RewardType
  status        RewardStatus @default(PENDING)
  value         Float
  description   String

  stripeCouponId    String?
  createdAt         DateTime  @default(now())
  appliedAt         DateTime?
  expiresAt         DateTime?

  user          User     @relation(fields: [userId], references: [id])
  referral      Referral @relation(fields: [referralId], references: [id])

  @@map("referral_rewards")
  @@index([userId])
  @@index([status])
}

enum ReferralStatus {
  PENDING
  CONVERTED
  REWARDED
  EXPIRED
  CANCELLED
}

enum RewardType {
  REFERRER_FREE_MONTH
  REFEREE_DISCOUNT
}

enum RewardStatus {
  PENDING
  APPLIED
  EXPIRED
  CANCELLED
}

// =============================================
// MODELO DE PRECIOS DE REFERENCIA (CACHE + AI)
// =============================================

// Cache de precios de referencia para calculadoras
model ReferencePrice {
  id          String   @id @default(cuid())
  category    String   // 'housing', 'vehicle', 'business'
  key         String   // 'apartment_economic', 'car_used', etc.
  description String   // 'Apartamento económico (Sto. Dgo. Norte)'
  amount      Int      // 3500000
  source      String?  // 'AI Search - SuperCasas, Corotos'
  country     String   @default("DO") // País de referencia
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  @@unique([category, key, country])
  @@index([category])
  @@index([country])
  @@map("reference_prices")
}

// Configuración del sistema de precios
model ReferencePriceConfig {
  id              String   @id @default(cuid())
  country         String   @unique // 'DO', 'MX', etc.
  cacheDays       Int      @default(90) // Días de validez del cache (3 meses)
  lastFullUpdate  DateTime?
  isUpdating      Boolean  @default(false)
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())

  @@map("reference_price_configs")
}

// =============================================
// MODELO DE REPORTES SEMANALES PRO
// =============================================

// Reportes semanales generados con IA para usuarios PRO
model WeeklyReport {
  id              String   @id @default(cuid())
  userId          String

  // Período del reporte
  weekStart       DateTime // Fecha inicio de la semana (lunes)
  weekEnd         DateTime // Fecha fin de la semana (domingo)

  // Resumen financiero
  totalIncome     Decimal  @db.Decimal(12, 2)
  totalExpenses   Decimal  @db.Decimal(12, 2)
  savingsRate     Float    // Porcentaje de ahorro
  financialScore  Int      // Score 0-100

  // Datos detallados (JSON)
  topCategories   Json     // Array de {category, amount, percentage}
  budgetsStatus   Json     // Array de {name, spent, limit, percentage}
  goalsProgress   Json     // Array de {name, current, target, percentage}
  antExpenses     Json     // {total, percentage, topItems}
  predictions     Json     // {endOfMonthSavings, budgetWarnings, etc}

  // Análisis de IA
  aiAnalysis      String   @db.Text // Texto largo del análisis de Zenio
  recommendations Json     // Array de strings con recomendaciones

  // Comparativa con semana anterior
  vsLastWeek      Json?    // {incomeChange, expensesChange, scoreChange}

  // Tracking de visualización
  viewedAt        DateTime? // null = no visto, fecha = visto
  notifiedAt      DateTime? // Cuando se envió la notificación

  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekStart]) // Solo un reporte por semana por usuario
  @@index([userId, createdAt])
  @@index([userId, viewedAt])
  @@map("weekly_reports")
}
