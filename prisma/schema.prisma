generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String        @id @default(cuid())
  name                String
  lastName            String
  email               String        @unique
  password            String
  phone               String
  birthDate           DateTime
  country             String
  state               String
  city                String
  currency            String
  preferredLanguage   String
  occupation          String
  company             String?
  verified            Boolean       @default(false)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  onboarding          Boolean       @default(false)
  onboardingCompleted Boolean       @default(false)

  // Password Reset Fields
  resetCode           String?
  resetCodeExpires    DateTime?
  onboardingData      Onboarding?
  budgets             Budget[]
  transactions        Transaction[]
  goals               Goal[]
  
  // Gamificación
  gamificationEvents  GamificationEvent[]
  finScoreHistory     FinScoreHistory[]
  userStreak          UserStreak?
  userBadges          UserBadge[]
  challengeParticipants ChallengeParticipant[]

  // Suscripciones y Pagos
  subscription        Subscription?
  payments            Payment[]
  stripeCustomerId    String?       @unique

  // Email Sync
  emailConnections    EmailConnection[]

  // Notificaciones Push (FCM)
  devices                   UserDevice[]
  notificationPreferences   NotificationPreferences?

  @@map("users")
}

model Transaction {
  id          String          @id @default(cuid())
  userId      String
  amount      Float
  type        TransactionType
  description String?
  date        DateTime        @default(now())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  category_id String
  category    Category        @relation(fields: [category_id], references: [id])
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transactions")
}

model Budget {
  id               String   @id @default(uuid())
  amount           Float
  alert_percentage Float    @default(80)
  category_id      String
  created_at       DateTime @default(now())
  end_date         DateTime
  is_active        Boolean  @default(true)
  name             String
  period           String
  spent            Float    @default(0)
  start_date       DateTime
  updated_at       DateTime @updatedAt
  user_id          String
  category         Category @relation(fields: [category_id], references: [id])
  user             User     @relation(fields: [user_id], references: [id])

  @@map("budgets")
}

model Onboarding {
  id                 String   @id @default(cuid())
  userId             String   @unique
  mainGoals          Json
  mainChallenge      String
  mainChallengeOther String?
  savingHabit        String
  emergencyFund      String
  financialFeeling   String
  incomeRange        String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])
}

model Category {
  id           String          @id @default(cuid())
  name         String
  type         TransactionType
  icon         String
  isDefault    Boolean         @default(true)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  budgets      Budget[]
  transactions Transaction[]
  goals        Goal[]
  merchantMappings MerchantCategoryMapping[]

  @@map("categories")
}

model Goal {
  id                        String    @id @default(uuid())
  userId                    String
  name                      String
  description               String?
  targetAmount              Float
  currentAmount             Float     @default(0)
  targetDate                DateTime?
  categoryId                String
  priority                  String    @default("medium")
  isCompleted               Boolean   @default(false)
  isActive                  Boolean   @default(true)
  monthlyTargetPercentage   Float?
  monthlyContributionAmount Float?
  contributionsCount        Int       @default(0)
  lastContributionDate      DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  user                      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  category                  Category  @relation(fields: [categoryId], references: [id])

  @@map("goals")
}

enum TransactionType {
  INCOME
  EXPENSE
}

// =============================================
// MODELOS DE GAMIFICACIÓN
// =============================================

// Sistema de Eventos de Gamificación
model GamificationEvent {
  id            String   @id @default(cuid())
  userId        String
  eventType     String   // 'add_tx', 'goal_complete', 'budget_overspend', etc.
  eventData     Json?    // Datos específicos del evento
  pointsAwarded Int      @default(0)
  createdAt     DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("gamification_events")
  @@index([userId, eventType])
  @@index([createdAt])
}

// FinScore Histórico  
model FinScoreHistory {
  id           String   @id @default(cuid())
  userId       String
  score        Int      // 0-100
  breakdown    Json     // {savings: 25, budget: 20, streak: 15, debt: 10}
  calculatedAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("finscore_history")
  @@index([userId, calculatedAt])
}

// Sistema de Rachas
model UserStreak {
  id                      String    @id @default(cuid())
  userId                  String    @unique
  currentStreak           Int       @default(0)
  longestStreak           Int       @default(0)
  lastActivityDate        DateTime?
  streakType              String    @default("daily") // 'daily', 'budget', 'savings'
  salvividasUsedThisMonth Boolean   @default(false)
  lastSalvividasDate      DateTime?
  updatedAt               DateTime  @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_streaks")
}

// Sistema de Badges
model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  badgeId   String   // 'primer_paso', 'planificador', etc.
  earnedAt  DateTime @default(now())
  isFeatured Boolean @default(false)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId])
  @@map("user_badges")
  @@index([userId])
}

// Desafíos Mensuales
model MonthlyChallenge {
  id            String   @id @default(cuid())
  name          String
  description   String
  startDate     DateTime
  endDate       DateTime
  criteria      Json     // Criterios específicos del desafío
  rewardBadgeId String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  
  participants ChallengeParticipant[]
  
  @@map("monthly_challenges")
  @@index([isActive, startDate, endDate])
}

// Participación en Desafíos
model ChallengeParticipant {
  id          String   @id @default(cuid())
  userId      String
  challengeId String
  joinedAt    DateTime @default(now())
  progress    Json     @default("{}")
  completed   Boolean  @default(false)
  rank        Int?     // Para rankings
  completedAt DateTime?
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge MonthlyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, challengeId])
  @@map("challenge_participants")
  @@index([challengeId, completed])
  @@index([userId])
}

// Enums para Gamificación
enum EventType {
  ADD_TX
  EDIT_TX
  DELETE_TX
  CREATE_BUDGET
  OVERSPEND
  WITHIN_BUDGET
  CREATE_GOAL
  GOAL_CONTRIB
  GOAL_COMPLETE
  TIP_ACCEPTED
  TIP_IGNORED
  DAILY_OPEN
  STREAK_BREAK
}

enum BadgeType {
  PRIMER_PASO
  PLANIFICADOR
  AHORRO_ROOKIE
  ZENIO_LOVER
  ANTI_DOOM_SPENDER
  RACHA_FUEGO
  AHORRADOR_NOVATO
  PRESUPUESTO_MAESTRO
  META_CRUSHER
}

// =============================================
// MODELOS DE SUSCRIPCIONES Y PAGOS
// =============================================

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  plan                 SubscriptionPlan   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  stripePriceId        String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  trialEndsAt          DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  // Contador de consultas de Zenio AI
  zenioQueriesUsed     Int                @default(0)
  zenioQueriesResetAt  DateTime           @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
  @@index([userId])
  @@index([status])
}

model Payment {
  id                    String        @id @default(cuid())
  userId                String
  subscriptionId        String?
  amount                Float
  currency              String        @default("usd")
  status                PaymentStatus
  stripePaymentIntentId String?       @unique
  stripeInvoiceId       String?       @unique
  description           String?
  createdAt             DateTime      @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
  @@index([userId])
  @@index([status])
}

enum SubscriptionPlan {
  FREE
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
  INCOMPLETE
  INCOMPLETE_EXPIRED
  UNPAID
}

enum PaymentStatus {
  SUCCEEDED
  FAILED
  PENDING
  REFUNDED
  CANCELED
}

// =============================================
// MODELOS DE EMAIL SYNC (Importacion de Gastos)
// =============================================

// Conexion de email del usuario
model EmailConnection {
  id                  String              @id @default(cuid())
  userId              String
  provider            EmailProvider       @default(GMAIL)
  email               String
  accessToken         String
  refreshToken        String?
  tokenExpiresAt      DateTime?
  isActive            Boolean             @default(true)
  lastSyncAt          DateTime?
  lastSyncStatus      EmailSyncStatus     @default(PENDING)
  lastSyncError       String?
  syncFrequencyHours  Int                 @default(1)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankFilters         BankEmailFilter[]
  importedEmails      ImportedBankEmail[]
  syncLogs            EmailSyncLog[]

  @@unique([userId, provider])
  @@map("email_connections")
  @@index([userId])
  @@index([isActive, lastSyncAt])
}

// Filtros de bancos configurados
model BankEmailFilter {
  id                String          @id @default(cuid())
  emailConnectionId String
  bankName          String
  senderEmails      String[]
  subjectKeywords   String[]
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  emailConnection   EmailConnection @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@map("bank_email_filters")
  @@index([emailConnectionId])
}

// Emails bancarios importados
model ImportedBankEmail {
  id                String                @id @default(cuid())
  emailConnectionId String
  gmailMessageId    String
  subject           String
  senderEmail       String
  receivedAt        DateTime
  rawContent        String?
  parsedData        Json?
  status            ImportedEmailStatus   @default(PENDING)
  errorMessage      String?
  transactionId     String?
  createdAt         DateTime              @default(now())
  processedAt       DateTime?

  emailConnection   EmailConnection       @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@unique([emailConnectionId, gmailMessageId])
  @@map("imported_bank_emails")
  @@index([emailConnectionId, status])
  @@index([gmailMessageId])
}

// Log de sincronizaciones
model EmailSyncLog {
  id                  String          @id @default(cuid())
  emailConnectionId   String
  startedAt           DateTime        @default(now())
  completedAt         DateTime?
  status              EmailSyncStatus
  emailsFound         Int             @default(0)
  emailsProcessed     Int             @default(0)
  emailsSkipped       Int             @default(0)
  transactionsCreated Int             @default(0)
  errorMessage        String?

  emailConnection     EmailConnection @relation(fields: [emailConnectionId], references: [id], onDelete: Cascade)

  @@map("email_sync_logs")
  @@index([emailConnectionId, startedAt])
}

// Bancos soportados
model SupportedBank {
  id              String    @id @default(cuid())
  name            String    @unique
  country         String    @default("DO")
  senderEmails    String[]
  subjectPatterns String[]
  parserTemplate  String?
  isActive        Boolean   @default(true)
  logoUrl         String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("supported_banks")
  @@index([country, isActive])
}

enum EmailProvider {
  GMAIL
  OUTLOOK
  IMAP
}

enum EmailSyncStatus {
  PENDING
  IN_PROGRESS
  SUCCESS
  FAILED
  PARTIAL
}

enum ImportedEmailStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  SKIPPED
  DUPLICATE
}

// =============================================
// MODELOS DE NOTIFICACIONES PUSH (FCM)
// =============================================

// Dispositivos del usuario para notificaciones push
model UserDevice {
  id          String   @id @default(cuid())
  userId      String
  fcmToken    String   @unique
  platform    DevicePlatform
  deviceName  String?
  appVersion  String?
  isActive    Boolean  @default(true)
  lastUsedAt  DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_devices")
  @@index([userId, isActive])
  @@index([fcmToken])
}

// Preferencias de notificación del usuario
model NotificationPreferences {
  id                    String   @id @default(cuid())
  userId                String   @unique

  // Tipos de notificaciones habilitadas
  emailSyncEnabled      Boolean  @default(true)
  budgetAlertsEnabled   Boolean  @default(true)
  goalRemindersEnabled  Boolean  @default(true)
  weeklyReportEnabled   Boolean  @default(true)
  tipsEnabled           Boolean  @default(true)

  // Umbral de alerta de presupuesto (porcentaje)
  budgetAlertThreshold  Int      @default(80)

  // Horario de notificaciones (para evitar molestias)
  quietHoursStart       Int?     // Hora en formato 24h (ej: 22 = 10pm)
  quietHoursEnd         Int?     // Hora en formato 24h (ej: 8 = 8am)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

// Historial de notificaciones enviadas
model NotificationLog {
  id          String             @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  body        String
  data        Json?
  status      NotificationStatus @default(PENDING)
  sentAt      DateTime?
  readAt      DateTime?
  errorMessage String?
  createdAt   DateTime           @default(now())

  @@map("notification_logs")
  @@index([userId, createdAt])
  @@index([type, status])
}

enum DevicePlatform {
  ANDROID
  IOS
}

enum NotificationType {
  EMAIL_SYNC_COMPLETE
  BUDGET_ALERT
  BUDGET_EXCEEDED
  GOAL_REMINDER
  GOAL_ACHIEVED
  WEEKLY_REPORT
  TIP
  SYSTEM
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  READ
}

// =============================================
// MODELO DE APRENDIZAJE DE CATEGORIZACIÓN
// =============================================

// Mapeo de comercios a categorías (sistema de aprendizaje)
model MerchantCategoryMapping {
  id              String   @id @default(cuid())

  // Usuario (null = mapeo global)
  userId          String?

  // Nombre del comercio normalizado (uppercase, sin espacios extra)
  merchantName    String

  // Patrón alternativo para variantes (ej: "FARM*" matchea "FARMACIA CAROL", "FARM RD", etc.)
  merchantPattern String?

  // Categoría asignada
  categoryId      String

  // Estadísticas de uso
  timesUsed       Int      @default(1)

  // Para mapeos globales: cuántos usuarios diferentes lo confirmaron
  confirmedByUsers Int     @default(1)

  // Origen del mapeo
  source          MappingSource @default(USER_CORRECTION)

  // Confianza del mapeo (0-100) - para mapeos globales
  confidence      Int      @default(100)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  category        Category @relation(fields: [categoryId], references: [id])

  // Índices para búsqueda eficiente
  @@unique([userId, merchantName])
  @@index([merchantName])
  @@index([userId])
  @@index([categoryId])
  @@map("merchant_category_mappings")
}

enum MappingSource {
  USER_CORRECTION    // Usuario corrigió manualmente
  ZENIO_CORRECTION   // Usuario corrigió via Zenio
  AI_CONFIRMED       // IA categorizó y usuario no corrigió (alta confianza)
  SYSTEM_DEFAULT     // Mapeo por defecto del sistema
}
